{
  "name": "Composer",
  "tagline": "A program that writes its own music",
  "body": "This program composes a piece, complete with both harmony and melody, and writes it to MIDI format. This works in both major and minor keys. For you TL;DR kind of people, here's a couple of pieces composed by the program: \r\n\r\nMinor Key: (it gets really interesting after ~22 seconds)\r\nhttps://drive.google.com/open?id=0B-yYdO8MBojUSE1KVnFFTGRYNGs\r\n\r\nMajor Key:\r\nhttps://drive.google.com/open?id=0B-yYdO8MBojUWWtYVlBfVnhSUTQ\r\n\r\n\r\n###Introduction:\r\nI was very surprised when I learned that musical automatons had already been in existence for at least several centuries. Perhaps most fascinating was David Roentgen's automaton modeled after Marie Antoinette in the 1700's. Roentgen's mechanical android strikes the strings of the instrument in perfect rhythm and with incredible precision, which is impressive given the technology available at the time.\r\n\r\nConsidering how far technology has advanced since then, I decided to take a crack at making my own autonomous instrument, but unlike the ones created during the renaissance and baroque periods, this instrument does not play preset pieces. Instead, it writes its own pieces. \r\n\r\nThis project explores the possibilities of music intelligence by first developing a program that can adhere to fundamental rules of western music theory, then then expanding on the program by attempting to imbue it with my own compositional style and preferences. Because this idea was, at the time, quite abstract, I decided to go for a more straight-forward implementation that involves hard-coding my own rules and probability distributions, rather than tackling it from an artificial intelligence and machine-learning standpoint.\r\n\r\n\r\n###Implementation\r\nMy approach is a rather simple one. In its most basic form, it essentially constructs a scale in a designated key, and psuedo-randomly selects notes from the scale with randomly generated durations. However, in order to make the composition sound less like a jumble of notes and more like a piece that was created with intention, a piece in its most basic form requires a chord progression, steady rhythm, phrasing, and cadence.\r\n\r\nMy initial thought was to deal with these aspects simultaneously, afterall music is very contextually dependent (i.e. the selection of a note often influences subsequent notes) and requires a kind of cohesiveness between all aspects from rhythm to pitch to appear \"complete\". However, because I wasn't even sure if this would work at the time, I decided, instead, to determine each of these aspects individually and (for the most part) independent of one another. This way, I could easily adjust invdividual parameters without needing to rewrite large chunks of code.\r\n\r\nTo keep things simple for now, all pieces are in 4/4 time, and each phrase is 4 measures long. To begin, I subdivided the composition into phrases, which were further subdivided into measures, and then notes. There are several stages this program goes through to compose a piece: we begin by establishing the chord progression of the song, determining a chord for every 2-4 beats. One crucial rule to apply here is that phrases often end with an authentic cadence, and this almost always resolves into the tonic as the piece ends.\r\n\r\nOnce the chord progression has been constructed, the program proceeds to use the chord progression to construct the melody and harmony (both independent of each other). This is done in two parts: First determine the rhythm of the entire piece, then determine the notes based on both the already-determined rhythm and chords.\r\n\r\nBecause I was hard-coding rules, I had to be careful of being too restrictive with my rules. For the most part, I managed to preserve as many degrees of freedom as I could. However, there were certain crucial parts of phrases that I had to be very specific about, such as the endings of phrases. By focusing on phrase endings, and allocating a high chance of ending in authentic cadences, and beginning with the tonic, I was able to achieve a greater sense of completion and coherence in each composition.\r\n\r\nHowever, even with these rules, the compositions still fell apart after several measures. The notes were oftentimes erratic, constantly jumping up and down large intervals. Here's an example of the types of compositions outputted at this stage of development:\r\n\r\nhttps://drive.google.com/open?id=0B-yYdO8MBojUVzBfOHB2US1TY2c\r\n\r\nAs you can see, it begins with a very coherent and interesting sound, but the uncontrolled and erratic jumps cause it to fall apart pretty quickly. To solve this problem, I needed context-dependent rules, where previous notes and rhythm determines the probabilities of subsequent notes. Unfortunately with my implementation, adding these rules became cumbersome and required many additional lines of code. It was difficult to keep the code clean without restructuring and rewriting large chunks of code. As a result, I only included a subset of rules I had wanted to include. The following are some of the rules I had included:\r\n\r\n-After selecting a note, determine the octave of the note based on the closest interval to the previous note: Because I selected from a scale of 7 notes, there was an annoying edge case where, for example, if the previous note was the tonic, and the selected note was the leading tone, the result would be a very sudden and usually unpleasant jump upwards from tonic to leading tone. This ignores the leading tone right below the tonic, which is much less jarring, and a much more natural musical tendency. The solution was simple: for every note chosen, examine the note at an octave above and below the previous note, and choose the octave with the least distance to the previous note.\r\n\r\n-Reweight probabilities of notes, giving greater favor to nearby notes if the rhythm is a fast one. This also works to reduce erratic jumps. If the previous note was an eigth note, then readjust the probabilities such that selecting a distant note is very unlikely. This weight becomes more extreme if the previous note is shorter.\r\n\r\n-Follow ascension/descension tendencies: If we take a truly random selection of notes, the chances of rising and falling in pitch are each ~50%. However, if you listen to any song, chances are that this is not the case. Typically, if a song moves up in pitch, then the subsequent notes are likely to continue the upward trend for a short period, and likewise for downward movement in pitch. To achieve something similar, the initial chances of rising or falling are each 50%. If the selected note is above the previous pitch, the chances of the next note being higher is increased by an arbitrary percentage. This increase continues as a curve that eventually plateaus after several consecutive increases. If the notes continue to rise after the probabilitiy plateaus, then the probability decreases linearly until the ascension trend is broken, in which case the probabilities are reset to 50%/50%. The same happens for descension in pitch.\r\n\r\nAdding just these three rules had a drastic effect in the outcome of the song. Although still a little bland, every so often the composition would sound like something I'd actually improvise, and there are often bits and pieces that sound like it as potential to evolve into a legitimate composition.\r\n\r\nAlthough I have structured the code in a way such that adding chords to compositions should be relatively easy and straightforward, I have decided to hold off on chords for the time being, at least until I've reached a satisfactory level of complexity in the compositions.\r\n\r\n\r\n###Results:\r\nAs expected, it was very difficult trying to capture such an abstract art with such a rigid and straight-forward implementation. The quality of the music produced is a hit or a miss. Every so often, there may be a musical phrase that sounds like it could develop into something with real potential, and on occasion I'll hear bits and pieces that very closely resembles my style of improvisation. But for the most part, the compositions are pretty bland, and on occasion falls apart musically.\r\n\r\nOn the bright side, this did turn out better than I thought it would. I realized it is not difficult to string together a coherent string of notes. Perhaps the greatest difficulty in creating something truly musical and interesting is making the program context-aware. I've only added some rules, but there are plenty more that I have in mind that I'd like to play around with in the near future. The only problem is that the way I designed the code makes it quite cumbersome to add such rules, and I would have to do some large code restructuring if I want to continue with this particular implementation.\r\n\r\nThis program can compose in both major and minor key. Currently, I'm omitting chords until I can get an acceptable level of quality in the music. \r\n\r\nHere are the results: \r\n\r\nThis one's pretty consistent. nothing special, but I do think it sounds pleasant. This is probably how the average composition sounds like.\r\nhttps://drive.google.com/open?id=0B-yYdO8MBojUWWtYVlBfVnhSUTQ\r\n\r\n\r\nThis is the most recent file generated by the program.\r\nhttps://drive.google.com/open?id=0B-yYdO8MBojUNmpnVkRQUHFucVE\r\n\r\n\r\nHere's another minor one. This one actually gets pretty interesting during the last 15 or so seconds.\r\nhttps://drive.google.com/open?id=0B-yYdO8MBojUSE1KVnFFTGRYNGs\r\n\r\n\r\nThis one starts off rough, but actually gets decent around 0:22:\r\nhttps://drive.google.com/open?id=0B-yYdO8MBojURldreWF4aDQ2VEE\r\n\r\n\r\nPiece from earlier stages of development:\r\n\r\nHere are a few examples of pieces that started off pretty well, but fall apart\r\ncomps/interestingstart.mid\r\nhttps://drive.google.com/open?id=0B-yYdO8MBojUSXF2UzhDR0NwWWM\r\n\r\nThe first 8 seconds are pretty fun, then it completely falls apart, haha.\r\nhttps://drive.google.com/open?id=0B-yYdO8MBojUVzBfOHB2US1TY2c\r\n\r\nThis is exactly what I mean by \"bland\". The notes do not go anywhere.\r\nhttps://drive.google.com/open?id=0B-yYdO8MBojUUDVZUktnZVBlQ1E\r\n\r\nThe original files are in MIDI format, so you can easily convert it into sheet-music using programs such as Noteflight or Finale.\r\n\r\n\r\n###FUTURE STEPS:\r\nAs it turns out, David Cope had already tried this decades ago, and like he, I realized that it's very difficult to try to capture the abstractness of music with such an inflexible and straight-forward implementation. Sure, it's definitely possible, but it would require a ton of code, and will probably become very messy, very quickly.\r\n\r\nPerhaps the best option would be to approach this problem from an artificial intelligence standpoint. Like I mentioned above, one solution is, perhaps, carefully parsing a batch of similarly-styled MIDI files and and aggregating the data into a structured decision tree, such that tree depth corresponds to time or beat number. I think, if structured carefully, the tree would be unconditionally context-aware, and doing a linear traversal down random branches should result in a song that flows well.\r\n\r\nThis idea is similar to David Cope's idea of recombinance, where Cope suggests breaking down and recombining parts from different pieces to create a new piece. However, rather than relying on the recombination of parts to create a piece, I want to instead use these parts as a means to teach the program certain subtle musical tendencies, which it could then use as a guideline to create something entirely new.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}